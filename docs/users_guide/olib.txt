///////
This file is included into the main SUG document, and is located under header level "=="
///////

Safir SDK Core contains a C++ _ODBC_ wrapper, which is located in the Safir.Databases.Odbc namespace. The wrapper library supports all odbc capable databases, but Saab are using the Mimer SQL database (http://www.mimer.com[]).

This library contains three different classes which groups different parts of the odbc interface. The first class is +Environment+ and this class contains the environment specific part of the odbc library. The environment is allocated once in an application and is used by odbc to store application global data. The next class is +Connection+ and this class contains all connection specific information. An application can have several connections made through a single environment if several queries needs to be made in parallel.  The last class is +Statement+ which contains all information about individual statements made through a connection.

The odbc wrapper also supports stored procedures, a small example of which can be seen in <<making_query>>.

=== Connecting
A connection to a database is made through an Connection object and a Connection object requires a Environment object. The first step to connect is to declare these two objects in the class that will use them.

.Declaring Connection and Environment
[source,{cpp}]
----------------------------
class EntryService
{
private:
    Safir::Databases::Odbc::Connection     m_connection;
    Safir::Databases::ODbc::Environment    m_environment;

public:
    bool Allocate();

    void Deallocate();
};
----------------------------

The second step is to allocate the environment and connection objects. This is done in the Allocate() method. The environment should be considered a static resource when allocated but the connection is a dynamic resource and may be lost during run-time. (The Allocate method is written so that it can be called again to re-connect to the database should the connection fail.)

.Allocating Environment and Connection
[source,{cpp}]
----------------------------
bool EntryService::Allocate()
{
    try
    {
        if (!m_environment.IsValid())
            m_environment.Alloc();

        if (!m_connection.IsValid())
            m_connection.Alloc(m_environment);      

        if (!m_connection.IsConnected())
        {
            m_connection.Connect
                (Capabilities::DiaryEntries::DiaryEntryDb::
                    Parameters::ConnectionString());
            m_connection.SetConnectAttr
                (SQL_ATTR_CONNECTION_TIMEOUT, 5L);
       }
    }
    catch(const Safir::Databases::ODbc::ReconnectException & ex)
    {
        ... error handling ...
    }
----------------------------

When both the environment and connection objects are allocated the connection to the RDBMS can be made. Before the connection is made a timeout period should be set. If no timeout period is set then ODBC will use an indefinite timeout period.

=== Exceptions
There are two exceptions that you need to handle when communicating with the database +Safir.Databases.Odbc.ReconnectException+ and +Safir.Databases.Odbc.RetryException+. When the first happens you have lost your connection to the database and you need to reconnect. The second happens if the database is ``too busy'' to handle your operation. In this case you need to retry the operation in a short while.

[[making_query]]
=== Making a query
Before a query to the database can be made the query has to be prepared properly. Preparing a query involves sending the actual sql statement to the database to be precompiled before execution. In the sql statement parameters can be set as a question mark (\'?\'). This tells the Database that a value will be sent for this parameter at execution time. By using parameters an application can prepare the queries it needs at start-up and then use them several times during run-time by setting the parameter values. The application needs to bind these parameters to specific variables that can be used to set the value of the parameters before execution. The columns in the recordset returned by the query is managed in a similar way to parameters. Each column is bound to variable that the application can read to process each row of the recordset. When setting up a query for later execution a timeout period should be set and if no timeout period is set then odbc will use an indefinite timeout period.

All queries are made through a connection and if that connection is lost all prepared statements made through that connection is also lost and must be remade. ODBC cannot manage multiple queries in a single connection so a query needs to be closed before setting up another. 

Declaration of variables used as parameters/columns in the query:

.Declarations
[source,{cpp}]
----------------------------
Statement         m_ReadStmt;         // The query object.
Int32Parameter    m_paramId;          // The parameter to the query.
Int32Column       m_columnAmount;     // The first field returned.
WideStringColumn  m_columnName;       // The second field returned.
----------------------------

Preparation of the statement and binding of parameters/columns:

.Preparing a statement
[source,{cpp}]
----------------------------
try
{
    if (!m_ReadStmt.IsValid())
    {
        m_ReadStmt.Alloc( &m_connection );
        m_ReadStmt.Prepare("call spReadEquipment(?)");
        m_ReadStmt.BindParameter(1, m_paramUnitId);
        m_ReadStmt.BindColumn(1, m_columnAmount);
        m_ReadStmt.BindColumn(2, m_columnName);
        m_ReadStmt.SetStmtAttr(SQL_ATTR_QUERY_TIMEOUT, 5L);
    }
}
catch(const Safir::Databases::Odbc::RetryException & ex)
{
    ... error handling ...
}
----------------------------

When executing a query all parameters to the query needs to be set and then +Execute+ is called. When +Execute+ is finished the query has been made but no information has yet been retrieved to the columns. This is made by the method +Fetch+. Each call to +Fetch+ retrieves a new row from the database and +Fetch+ can be called until it returns false to signal that all rows has been returned. If no rows was returned by the query the +Fetch+ will return false on the first call. After all rows has been processed then the query should be closed to release the rows returned by the query. After the query has been closed the statement is ready to be used again.

.Executing and fetching the result
[source,{cpp}]
----------------------------
try
{
    m_paramId.SetValue(1);              // Set parameter value.
    m_ReadStmt.Execute();               // Execute the query.
    bContinue = m_ReadStmt.Fetch(); // Read first row.
    while (bContinue)
    {
        if (!m_columnName.IsNull())
        {
            Do(m_columnName.GetValue());    // Process Name.
        }

        if (!m_columnAmount.IsNull())
        {
            Do(m_columnAmount.GetValue());  // Process Amount
        }

        bContinue = m_ReadStmt.Fetch(); // Read next row.
    }

    m_ReadStmt.CloseCursor();       // Close this query.
}
catch(const Safir::Databases::Odbc::RetryException & ex)
{
    ... error handling ...
}
----------------------------

=== Transactions
When setting up the connection to the database we also specify whether transactions are manual or automatic. If nothing else is specified then the connection will be using automatic transaction and every update will be committed when completed. If something more complex is required such as creating a new vehicle table row and a new equipment table row within one transaction then manual transactions should be used. Manual transactions require that +UseManualTransactions()+ is called on the connection and that calls commit or rollback are made when the transaction is finished.

.Calling +UseManualTransactions+ in Allocate
[source,{cpp}]
----------------------------
if (!m_connection.IsConnected())
{
     m_connection.Connect
         (Capabilities::DiaryEntries::DiaryEntryDb::
              Parameters::ConnectionString());
     m_connection.UseManualTransactions();
     m_connection.SetConnectAttr(SQL_ATTR_CONNECTION_TIMEOUT, 5L);
}
----------------------------

The +Commit+ function is to be called when all operations are completed successfully and all updates shall be written to the database persistently for use by other operations. If an error has occurred then the function +Rollback+ shall be called to remove all changes this transaction has made.

.Transaction example
[source,{cpp}]
----------------------------
try
{
    m_paramId.SetValue(1);
    m_DeleteStmt.Execute();
    m_pConnection->Commit();
}
catch(const Safir::Databases::Odbc::RetryException & ex)
{       
    m_pConnection->Rollback();

    ... more error handling ...
}
----------------------------

