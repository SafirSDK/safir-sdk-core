/******************************************************************************
*
* Copyright Saab AB, 2006-2013 (http://safir.sourceforge.net)
* 
* Created by: Mikael Wennerberg / stmiwn
*
*******************************************************************************
*
* This file is part of Safir SDK Core.
*
* Safir SDK Core is free software: you can redistribute it and/or modify
* it under the terms of version 3 of the GNU General Public License as
* published by the Free Software Foundation.
*
* Safir SDK Core is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with Safir SDK Core.  If not, see <http://www.gnu.org/licenses/>.
*
******************************************************************************/

#include "dll_imports.h"
#include <Safir/Utilities/Internal/LowLevelLogger.h>
#include <Safir/Utilities/DynamicLibraryLoader.h>

namespace Safir
{
    namespace Dob
    {
        namespace Typesystem
        {

            namespace 
            {
                void LoadDll(const std::string& name, bool global = false)
                {
                    lllout << "Loading " << name.c_str() << std::endl;
                    Safir::Utilities::DynamicLibraryLoader lib;
#if defined (_MSC_VER) && !defined(NDEBUG)
                    lib.Load(name + "d", false, global);
#else
                    lib.Load(name, false, global);
#endif
                }

            }


            Dll_Imports * volatile Dll_Imports::m_pInstance = 0;
            boost::once_flag Dll_Imports::m_onceFlag = BOOST_ONCE_INIT;

            void Dll_Imports::Create()
            {
                m_pInstance = new Dll_Imports();

                //On some linux systems (e.g. Ubuntu 11.10) the loading
                //of the dlls will fail when we're running a dotnet or java
                //program, so if that happens we recursively load ourselves in 
                //global mode, and try again. This seems to work fine...
                try
                {
                    m_pInstance->LoadAllDlls();
                }
                catch (const std::logic_error&)
                {
                    lllout << "LoadAllDlls failed, will try again after loading dots_generated-cpp in global mode" << std::endl;
                    LoadDll("dots_generated-cpp", true);
                    m_pInstance->LoadAllDlls();                                    
                }
            }
            
            bool Dll_Imports::Init()
            {
                //TODO: this whole initialization business is terribly buggy!
                //But I had to replace the mutex with a call_once, to at least not make
                //matters worse...
                //Basically the instantiation is not thread-safe at all!
                //and the LoadAllDlls routine will recursively call Init()!
                if (m_pInstance == NULL)
                {
                    boost::call_once(m_onceFlag,Dll_Imports::Create);
                }
                return true;
            }

            Dll_Imports::Dll_Imports()
            {

            }

            Dll_Imports::~Dll_Imports()
            {

            }

            void Dll_Imports::LoadAllDlls()
            {
@LoadDll
            }


        }
    }
}



