/******************************************************************************
*
* Copyright Saab AB, 2004-2023 (http://safirsdkcore.com)
*
* Created by: Joel Ottosson
*
*******************************************************************************
*
* This file is part of Safir SDK Core.
*
* Safir SDK Core is free software: you can redistribute it and/or modify
* it under the terms of version 3 of the GNU General Public License as
* published by the Free Software Foundation.
*
* Safir SDK Core is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with Safir SDK Core.  If not, see <http://www.gnu.org/licenses/>.
*
******************************************************************************/
#pragma once

#include <iostream>
#include <algorithm>
#include <boost/filesystem.hpp>
#include <boost/property_tree/ptree.hpp>
#include <boost/property_tree/xml_parser.hpp>
#include <boost/algorithm/string.hpp>
#include <Safir/Dob/Typesystem/ToolSupport/TypeParser.h>
#include <Safir/Utilities/Internal/ConfigReader.h>


// Class that searches for overridden dou-files that matches a specific checksum. Used in the case the generated code has
// wrong checksum compared to dots_kernel.
class DouDiffHelper
{
public:
    typedef std::vector<std::pair<std::string, std::string>> NameTypeVector;

    struct DiffResult
    {
        std::string typeName;
        bool hasDiff;
        NameTypeVector missingMembers;
        NameTypeVector addedMembers;
        NameTypeVector missingParameters;
        NameTypeVector addedParameters;
        NameTypeVector missingCreateRoutineValues;

        std::string ToString() const
        {
            if (!hasDiff)
            {
                return "Found dou-file but couldn't find any differences for type: " + typeName;
            }

            std::ostringstream os;
            os << "The dou-file differs from the generated code for type '" << typeName << "':" << std::endl;
            for (const auto& m : missingMembers)
            {
                os << "  - Member '" << m.second << " " << m.first << "' is missing." << std::endl;
            }
            for (const auto& m : addedMembers)
            {
                os << "  - Member '" << m.second << " " << m.first << "' has been added." << std::endl;
            }
            for (const auto& m : missingParameters)
            {
                os << "  - Parameter '" << m.second << " " << m.first << "' is missing." << std::endl;
            }
            for (const auto& m : addedParameters)
            {
                os << "  - Parameter '" << m.second << " " << m.first << "' has been added." << std::endl;
            }
            if (!missingCreateRoutineValues.empty())
            {
                os << "  - There are changes to CreateRoutines that may cause runtime errors." << std::endl
                   << "    The compiled code will look for the following parameters that no longer exists" << std::endl
                   << "    (generated DOB-parameters from default values in CreateRoutines):" << std::endl;

                for (const auto& m : missingCreateRoutineValues)
                {
                    os << "      - " << m.first << std::endl;
                    //os << "  - CreateRoutine for member '" << m.first << " is missing in createRoutine " << m.second << std::endl;
                }
            }

            return os.str();
        }
    };

    DouDiffHelper()
    {
        std::vector<boost::filesystem::path> rootDirs, domFiles;
        Safir::Utilities::Internal::ConfigReader reader;
        auto dirs = Safir::Utilities::Internal::ConfigHelper::GetDouDirectories(reader);
        for (const auto& d : dirs)
        {
            boost::filesystem::path douDirectory(d.second);
            rootDirs.push_back(douDirectory);
        }

        Safir::Dob::Typesystem::ToolSupport::GetFilesFromRootDirectories(rootDirs, m_douFiles, domFiles);
    }

    DouDiffHelper(const std::vector<boost::filesystem::path>& rootDirs)
    {
        std::vector<boost::filesystem::path> domFiles;
        Safir::Dob::Typesystem::ToolSupport::GetFilesFromRootDirectories(rootDirs, m_douFiles, domFiles);
    }

    // This method tries to find an overridden dou-file that matches the expected checksum. If we find such dou-file then
    // it is the one that was used by DobMake, and we can make a diff against the type info in dots_kernel to give more
    // specific information about what has changed since the source code was generated by DobMake.
    // Returns true if a dou-file was found with matching typeName and checksum.
    bool LoadType(const std::string& typeName, int64_t checksum)
    {
        m_diff.typeName = typeName;
        m_diff.hasDiff = false;
        m_diff.missingMembers.clear();
        m_diff.addedMembers.clear();
        m_diff.missingParameters.clear();
        m_diff.addedParameters.clear();
        m_diff.missingCreateRoutineValues.clear();

        m_members.clear();
        m_parameters.clear();

        // The first dou-file in the vector is the original.
        auto it = std::find_if(m_douFiles.begin(), m_douFiles.end(), [&typeName](auto f){return f.stem()==typeName;});
        if (it == m_douFiles.end())
        {
            // No dou-file found, in this case the only way is to manually differ the dou-file with the generated code to see whats wrong.
            std::cout << "Type not found: " << typeName << std::endl;
            return false;
        }

        boost::property_tree::ptree pt;
        boost::property_tree::read_xml(it->string(), pt, boost::property_tree::xml_parser::no_comments);
        auto members = pt.get_child_optional("class.members");
        if (members)
        {
            for (const auto& t : *members)
            {
                auto name = t.second.get<std::string>("name");
                auto type = t.second.get<std::string>("type");
                m_members.emplace_back(name, type);
            }
        }

        auto parameters = pt.get_child_optional("class.parameters");
        if (parameters)
        {
            for (const auto& t : *parameters)
            {
                auto name = t.second.get<std::string>("name");
                auto type = t.second.get<std::string>("type");
                m_parameters.emplace_back(name, type);
            }
        }

        auto createRoutines = pt.get_child_optional("class.createRoutines");
        if (createRoutines)
        {
            for (const auto& cr : *createRoutines)
            {
                auto crName = cr.second.get<std::string>("name");
                auto vals = cr.second.get_child_optional("values");

                if (vals)
                {
                    for (const auto& v : *vals)
                    {
                        auto member = v.second.get<std::string>("member");

                        // If referencing an existing parameter the element <parameter> is alway used. If the parameter is
                        // inline there are several options like: <value>, <entityId>, <MyClass> etc.
                        auto isInlineParameter = !v.second.get_optional<std::string>("parameter").has_value();
                        if (isInlineParameter)
                        {
                            // We have found a createRoutine with a member value that is not valueRef, i.e an hidden parameter.
                            // Example of an inline parameter name: memberName@MyNamespace.MyClass.MyCreateRoutine#inParam1#inParam2
                            std::string crSignature = member + "@" + typeName + "." + crName;

                            // If the createRoutine has in-parameters they must be appended to the signature as #param1#param2...#paramN
                            auto params = cr.second.get_child_optional("parameters");
                            if (params)
                            {
                                for (const auto& p : *params)
                                {
                                    if (p.first == "member")
                                    {
                                        crSignature += "#" + p.second.data();
                                    }
                                }
                            }

                            m_createRoutineValues.emplace_back(crSignature, "");
                        }
                    }
                }
            }
        }

        auto calculatedChecksum = CalculateChecksum();
        std::cout << "File found: " << it->string() << std::endl;
        //std::cout << "Calculated: " << calculatedChecksum << ", SearchedForGenerated: " << checksum << std::endl;

        return calculatedChecksum == checksum;
    }

    // The data passed to this function has been loaded by dots_kernel. This method compares the data against the original version
    // that was used to generate the classes.
    const DouDiffHelper::DiffResult& DiffLoadedType(const NameTypeVector& members, const NameTypeVector& allParameters)
    {
        // Clear
        m_diff.missingMembers.clear();
        m_diff.addedMembers.clear();
        m_diff.missingParameters.clear();
        m_diff.addedParameters.clear();
        m_diff.missingCreateRoutineValues.clear();

        // Separate normal parameters from hidden parameters
        NameTypeVector parameters, hidden;
        for (const auto& v : allParameters)
        {
            if (std::find(v.first.begin(), v.first.end(), '@') == v.first.end())
            {
                parameters.push_back(v);
            }
            else
            {
                hidden.push_back({v.first, ""});
            }
        }


        // Get diffs in the in-params to this function.
        m_diff.missingMembers = GetMissingInSecondVector(m_members, members);
        m_diff.addedMembers = GetMissingInSecondVector(members, m_members);
        m_diff.missingParameters = GetMissingInSecondVector(m_parameters, parameters);
        m_diff.addedParameters = GetMissingInSecondVector(parameters, m_parameters);
        m_diff.missingCreateRoutineValues = GetMissingInSecondVector(m_createRoutineValues, hidden);

        m_diff.hasDiff = !(m_diff.missingMembers.empty() && m_diff.addedMembers.empty() &&
                           m_diff.missingParameters.empty() && m_diff.addedParameters.empty() &&
                           m_diff.missingCreateRoutineValues.empty());

        return m_diff;
    }

private:
    std::vector<boost::filesystem::path> m_douFiles; // all dou-files including overridden files

    // Currently loaded type info
    NameTypeVector m_members;  // pair <name, type>
    NameTypeVector m_parameters; // pair <name, type>
    NameTypeVector m_createRoutineValues; // pair <memberName, full_createRoutineName>  ex <MyMember, MyNamespace.MyClass.MyCreateRoutine#inParam>

    // Diff result of currently loaded type
    DouDiffHelper::DiffResult m_diff;

    int64_t CalculateChecksum() const
    {
        std::vector<std::string> values;
        for (const auto& val : m_members)
        {
            values.push_back(val.first + ":" + val.second);
        }
        for (const auto& val : m_parameters)
        {
            values.push_back(val.first + ":" + val.second);
        }
        for (const auto& val : m_createRoutineValues)
        {
            values.push_back(val.first);
        }

        if (values.empty())
        {
            return 0;
        }

        std::sort(values.begin(), values.end());
        std::string checksumStr = boost::algorithm::join(values, ",");
        std::cout << "Checksum string: " << checksumStr << std::endl;
        return LlufId_Generate64(checksumStr.c_str());
    }

    // Get a list of all values that are present in the src but not in other
    NameTypeVector GetMissingInSecondVector(const NameTypeVector& src, const NameTypeVector& other) const
    {
        NameTypeVector missing;
        for (const auto& val : src)
        {
            if (std::find_if(other.begin(), other.end(), [&val](const auto& v2){ return val.first == v2.first && val.second == v2.second; }) == other.end())
            {
                missing.push_back(val);
            }
        }

        return missing;
    }
};

std::ostream& operator<<(std::ostream& os, const DouDiffHelper::DiffResult& obj)
{
    // write obj to stream
    os << obj.ToString();
    return os ;
}
