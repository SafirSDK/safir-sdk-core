/******************************************************************************
*
* Copyright Saab AB, 2004-2023 (http://safirsdkcore.com)
*
* Created by: Joel Ottosson
*
*******************************************************************************
*
* This file is part of Safir SDK Core.
*
* Safir SDK Core is free software: you can redistribute it and/or modify
* it under the terms of version 3 of the GNU General Public License as
* published by the Free Software Foundation.
*
* Safir SDK Core is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with Safir SDK Core.  If not, see <http://www.gnu.org/licenses/>.
*
******************************************************************************/
#pragma once

#include <iostream>
#include <algorithm>
#include <boost/filesystem.hpp>
#include <boost/property_tree/ptree.hpp>
#include <boost/property_tree/xml_parser.hpp>
#include <boost/algorithm/string.hpp>
#include <Safir/Dob/Typesystem/ToolSupport/TypeParser.h>
#include <Safir/Utilities/Internal/ConfigReader.h>


// Class that searches for overridden dou-files that matches a specific checksum. Used in the case the generated code has
// wrong checksum compared to dots_kernel.
class DouDiffHelper
{
public:
    typedef std::vector<std::pair<std::string, std::string>> NameTypeVector;

    struct DiffResult
    {
        std::string typeName;
        bool hasDiff;
        NameTypeVector missingMembers;
        NameTypeVector addedMembers;
        NameTypeVector missingParameters;
        NameTypeVector addedParameters;

        std::string ToString() const
        {
            if (!hasDiff)
            {
                return "Found dou-file but couldn't find any differences for type: " + typeName;
            }

            std::ostringstream os;
            os << "The dou-file differs from the generated code for type '" << typeName << "':" << std::endl;
            for (const auto& m : missingMembers)
            {
                os << "  - Member '" << m.second << " " << m.first << "' is missing." << std::endl;
            }
            for (const auto& m : addedMembers)
            {
                os << "  - Member '" << m.second << " " << m.first << "' has been added." << std::endl;
            }
            for (const auto& m : missingParameters)
            {
                os << "  - Parameter '" << m.second << " " << m.first << "' is missing." << std::endl;
            }
            for (const auto& m : addedParameters)
            {
                os << "  - Parameter '" << m.second << " " << m.first << "' has been added." << std::endl;
            }

            return os.str();
        }
    };

    DouDiffHelper()
    {
        std::vector<boost::filesystem::path> rootDirs, domFiles;
        Safir::Utilities::Internal::ConfigReader reader;
        auto dirs = Safir::Utilities::Internal::ConfigHelper::GetDouDirectories(reader);
        for (const auto& d : dirs)
        {
            boost::filesystem::path douDirectory(d.second);
            rootDirs.push_back(douDirectory);
        }

        Safir::Dob::Typesystem::ToolSupport::GetFilesFromRootDirectories(rootDirs, m_douFiles, domFiles);
    }

    DouDiffHelper(const std::vector<boost::filesystem::path>& rootDirs)
    {
        std::vector<boost::filesystem::path> domFiles;
        Safir::Dob::Typesystem::ToolSupport::GetFilesFromRootDirectories(rootDirs, m_douFiles, domFiles);
    }

    // This method tries to find an overridden dou-file that matches the expected checksum. If we find such dou-file then
    // it is the one that was used by DobMake, and we can make a diff against the type info in dots_kernel to give more
    // specific information about what has changed since the source code was generated by DobMake.
    // Returns true if a dou-file was found with matching typeName and checksum.
    bool LoadType(const std::string& typeName, int64_t checksum)
    {
        m_diff.typeName = typeName;
        m_diff.hasDiff = false;
        m_diff.missingMembers.clear();
        m_diff.addedMembers.clear();
        m_diff.missingParameters.clear();
        m_diff.addedParameters.clear();

        m_members.clear();
        m_parameters.clear();

        // The first dou-file in the vector is the original.
        auto it = std::find_if(m_douFiles.begin(), m_douFiles.end(), [&typeName](auto f){return f.stem()==typeName;});
        if (it == m_douFiles.end())
        {
            // No dou-file found, in this case the only way is to manually differ the dou-file with the generated code to see whats wrong.
            std::cout << "Type not found: " << typeName << std::endl;
            return false;
        }

        boost::property_tree::ptree pt;
        boost::property_tree::read_xml(it->string(), pt, boost::property_tree::xml_parser::no_comments);
        auto members = pt.get_child_optional("class.members");
        if (members)
        {
            for (const auto& t : *members)
            {
                auto name = t.second.get<std::string>("name");
                auto type = t.second.get<std::string>("type");
                m_members.emplace_back(name, type);
            }
        }

        auto parameters = pt.get_child_optional("class.parameters");
        if (parameters)
        {
            for (const auto& t : *parameters)
            {
                auto name = t.second.get<std::string>("name");
                auto type = t.second.get<std::string>("type");
                m_parameters.emplace_back(name, type);
            }
        }

        auto calculatedChecksum = CalculateChecksum();
        std::cout << "File found: " << it->string() << std::endl;
        std::cout << "Calculated: " << calculatedChecksum << ", SearchedForGenerated: " << checksum << std::endl;

        return calculatedChecksum == checksum;
    }

    // Frågar med override versionen. Denna metod jämför mot ursprungsversione som genererat klasserna
    const DouDiffHelper::DiffResult& DiffLoadedType(const NameTypeVector& members, const NameTypeVector& parameters)
    {
        // Clear
        m_diff.missingMembers.clear();
        m_diff.addedMembers.clear();
        m_diff.missingParameters.clear();
        m_diff.addedParameters.clear();

        // Get diffs in the in-params to this function.
        m_diff.missingMembers = GetMissingInSecontVector(m_members, members);
        m_diff.addedMembers = GetMissingInSecontVector(members, m_members);
        m_diff.missingParameters = GetMissingInSecontVector(m_parameters, parameters);
        m_diff.addedParameters = GetMissingInSecontVector(parameters, m_parameters);

        m_diff.hasDiff = !(m_diff.missingMembers.empty() && m_diff.addedMembers.empty() &&
                         m_diff.missingParameters.empty() && m_diff.addedParameters.empty());

        return m_diff;
    }

private:
    std::vector<boost::filesystem::path> m_douFiles; // all dou-files includeing overridden files

    // Currently loaded type info
    NameTypeVector m_members;  // pair <name, type>
    NameTypeVector m_parameters; // pair <name, type>

    // Diff result of currently loaded type
    DouDiffHelper::DiffResult m_diff;

    int64_t CalculateChecksum() const
    {
        std::vector<std::string> values;
        for (const auto& val : m_members)
        {
            values.push_back(val.first + ":" + val.second);
        }
        for (const auto& val : m_parameters)
        {
            values.push_back(val.first + ":" + val.second);
        }

        if (values.empty())
        {
            return 0;
        }

        std::sort(values.begin(), values.end());
        std::string checksumStr = boost::algorithm::join(values, ",");
        return LlufId_Generate64(checksumStr.c_str());
    }

    NameTypeVector GetMissingInSecontVector(const NameTypeVector& src, const NameTypeVector& other) const
    {
        NameTypeVector missing;
        for (const auto& val : src)
        {
            if (std::find_if(other.begin(), other.end(), [&val](const auto& v2){ return val.first == v2.first && val.second == v2.second; }) == other.end())
            {
                missing.push_back(val);
            }
        }

        return missing;
    }
};

std::ostream& operator<<(std::ostream& os, const DouDiffHelper::DiffResult& obj)
{
    // write obj to stream
    os << obj.ToString();
    return os ;
}
